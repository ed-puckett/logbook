<!DOCTYPE html>
<html lang="en" view="output" autoeval>
<head>
    <meta charset="utf-8">
    <script type="module" src="../dist/main.js"></script>
</head>
<body>
<eval-cell data-output-element-id="id-d2d603d7-568e-4b7e-8bda-0d4593bdb716" data-input-type="javascript">
class WorkerPool {
    static async create() {
        const worker_pool = new this();
        worker_pool.#update_pool();
        return worker_pool;
    }

    constructor(worker_count=navigator.hardwareConcurrency) {
        Object.defineProperties(this, {
            worker_count: {
                value: worker_count,
                enumerable: true,
            },
        });
        this.#workers = [];
    }
    #workers;

    get workers (){
        if (this.#workers.some(w =&gt; w.terminated)) {
            this.#update_pool();
        }
        return this.#workers;
    }

    async #update_pool() {
        this.#workers = this.#workers.filter(w =&gt; !w.terminated);
        for (let i = this.#workers.length; i &lt; this.worker_count; i++) {
            this.#workers.push(await create_worker({ keepalive: true }));
        }
    }
};

this.WorkerPool = WorkerPool;</eval-cell>
<output class="eval-cell-output" id="id-d2d603d7-568e-4b7e-8bda-0d4593bdb716"><div data-type="javascript"></div></output>
<eval-cell data-output-element-id="id-748d7ef7-e25e-42ca-b998-be9266ad482f" data-input-type="javascript">
const html = `
&lt;style&gt;
    #ode_plotter_info_display {
        display: flex;
        gap: 2rem;
    }

    #ode_plotter_play_controls {
        padding-top: 0.5rem;
        padding-bottom: 0.5rem;
    }

    #ode_plotter_controls {
        width: fit-content;
    }
    #ode_plotter_controls div * {
        vertical-align: middle;
    }

    #ode_plotter_adjustments {
        display: grid;
        grid-template-columns: max-content max-content;
        gap: 0.5rem;
    }
    #ode_plotter_adjustments label {
        justify-self: end;
    }

    #ode_plotter_config_display {
        width: fit-content;
        font-family: monospace;
    }

    .ode_plotter_display {
        margin-left: 0.1rem;
        padding: 0 0.5rem;
        background-color: #eee;
    }

    .hidden {
        display: none;
    }
&lt;/style&gt;

&lt;div id="ode_plotter_play_controls"&gt;
    &lt;button id="ode_plotter_go"&gt;Go&lt;/button&gt;
    &lt;button id="ode_plotter_pause" class="hidden"&gt;Pause&lt;/button&gt;
&lt;/div&gt;
&lt;div id="ode_plotter_info_display"&gt;
    &lt;div id="ode_plotter_controls"&gt;
        &lt;div id="ode_plotter_adjustments"&gt;
            &lt;label for="points_per_loop"&gt;Time steps per loop&lt;/label&gt;
            &lt;div&gt;
                &lt;input id="points_per_loop" type="range" min="1" max="10000" value="1000"&gt;
                &lt;span id="points_per_loop_display" class="ode_plotter_display"&gt;&lt;/span&gt;
            &lt;/div&gt;
            &lt;label for="loop_delay"&gt;Loop delay&lt;/label&gt;
            &lt;div&gt;
                &lt;input id="loop_delay" type="range" min="0" max="500" value="0"&gt;
                &lt;span id="loop_delay_display" class="ode_plotter_display"&gt;&lt;/span&gt; ms
            &lt;/div&gt;
            &lt;label for="points_shown"&gt;Time steps shown&lt;/label&gt;
            &lt;div&gt;
                &lt;input id="points_shown" type="range" min="0" max="100000" step="10" value="20000"&gt;
                &lt;span id="points_shown_display" class="ode_plotter_display"&gt;&lt;/span&gt;
            &lt;/div&gt;
            &lt;label for="point_count_display"&gt;Total time steps&lt;/label&gt;
            &lt;div&gt;
                &lt;span id="point_count_display" class="ode_plotter_display"&gt;&lt;/span&gt;
            &lt;/div&gt;
            &lt;label class="hidden" for="point_cloud_loop_display"&gt;Point cloud steps&lt;/label&gt;
            &lt;div class="hidden"&gt;
                &lt;span id="point_cloud_loop_display" class="ode_plotter_display"&gt;&lt;/span&gt;
            &lt;/div&gt;
            &lt;label class="hidden" for="point_cloud_points_per_loop"&gt;PC steps per loop&lt;/label&gt;
            &lt;div class="hidden"&gt;
                &lt;input id="point_cloud_points_per_loop" type="range" min="1" max="100" value="1"&gt;
                &lt;span id="point_cloud_points_per_loop_display" class="ode_plotter_display"&gt;&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div id="ode_plotter_config_display"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id="ode_plotter_plot"&gt;&lt;/div&gt;
`;

const worker_pool = await this.WorkerPool.create();;

function setup(ocx, the_equation_def) {
    ocx.create_child().innerHTML = html;

    const plot_el = document.getElementById('ode_plotter_plot');

    const go_button    = document.getElementById('ode_plotter_go');
    const pause_button = document.getElementById('ode_plotter_pause');

    function set_go_button_state(running) {
        if (running) {
            go_button.innerText = 'Stop';
        } else {
            go_button.innerText = 'Go';
        }
    }

    function set_pause_button_state(paused, running) {
        pause_button.innerText = paused ? 'Resume' : 'Pause';
        if (running) {
            pause_button.classList.remove('hidden');
        } else {
            pause_button.classList.add('hidden');
        }
    }
    set_go_button_state(false);
    set_pause_button_state(false, false);

    const points_per_loop_el     = document.getElementById('points_per_loop');
    const loop_delay_el          = document.getElementById('loop_delay');
    const points_shown_el        = document.getElementById('points_shown');
    const point_count_display_el = document.getElementById('point_count_display');

    const point_cloud_loop_display_el           = document.getElementById('point_cloud_loop_display');
    const point_cloud_loop_display_parent_el    = point_cloud_loop_display_el.parentElement;
    const point_cloud_loop_display_label_el     = document.querySelector('label[for="point_cloud_loop_display"]');
    const point_cloud_points_per_loop_label_el  = document.querySelector('label[for="point_cloud_points_per_loop"]');
    const point_cloud_points_per_loop_el        = document.getElementById('point_cloud_points_per_loop');
    const point_cloud_points_per_loop_parent_el = point_cloud_points_per_loop_el.parentElement;

    for (const range_id of [
        'points_per_loop',
        'loop_delay',
        'points_shown',
        'point_cloud_points_per_loop',
    ]) {
        const range_el   = document.getElementById(range_id);
        const display_el = document.getElementById(`${range_id}_display`);
        display_el.innerText = range_el.value;
        range_el.addEventListener('input', (event) =&gt; {
            display_el.innerText = range_el.value;
        });
    }

    function set_point_cloud_loop_display(visible, value='') {
        point_cloud_loop_display.innerText = value;
        const affected_els = [
            point_cloud_loop_display_parent_el,
            point_cloud_loop_display_label_el,
            point_cloud_points_per_loop_label_el,
            point_cloud_points_per_loop_parent_el,
        ];
        if (visible) {
            for (const el of affected_els) {
                el.classList.remove('hidden');
            }
        } else {
            for (const el of affected_els) {
                el.classList.add('hidden');
            }
        }
    }
    set_point_cloud_loop_display(false);

    const config_display_el = document.getElementById('ode_plotter_config_display');

    function display_config(config) {
        if (!config) {
            config_display_el.classList.add('hidden');
            config_display_el.innerText = '';
        } else {
            config_display_el.classList.remove('hidden');
            const { dt, x0, params, skip, steps, point_cloud } = config;
            const lines = [];
            lines.push('--- CONFIG ---');
            lines.push(`dt: ${dt}`);
            lines.push(`x0: [${x0.join(', ')}]`);
            if (params) {
                let params_str;
                if (typeof params === 'object') {
                    try {
                        params_str = JSON.stringify(params);
                    } catch (_) {
                        params_str = params.toString();
                    }
                } else {
                    params_str = params.toString();
                }
                lines.push(`params: ${params_str}`);
            }
            if (skip) {
                lines.push(`skip: ${skip}`);
            }
            if (steps) {
                lines.push(`steps: ${steps}`);
            }
            if (point_cloud) {
                const { n, c, r, dt:pc_dt=dt, steps:pc_steps } = point_cloud;
                lines.push(`--- point cloud ---`);
                lines.push(`n: ${n}, c: [${c.join(', ')}], dt: ${pc_dt}${pc_steps ? `, steps:${pc_steps}` : ''}}`);
            }
            config_display_el.innerText = lines.join('\n');
        }
    }

    display_config();

    const plot_height = 720;
    plot_el.style = `height: ${plot_height}px`;

    const Generator = Object.getPrototypeOf(function*(){}).constructor;

    function validate_f(f) {
        if (typeof f !== 'function') {
            throw new Error('f must be a function');
        }
    }
    function validate_integrator(integrator) {
        if (typeof integrator !== 'function') {
            throw new Error('integrator must be a function');
        }
    }
    function validate_point_cloud(point_cloud) {
        if ( typeof point_cloud !== 'object') {
            throw new Error('point_cloud must be an object')
        }
        const { n, c, r, dt, steps } = point_cloud;
        if (typeof n === 'undefined') {
            throw new Error('point_cloud.n must be defined');
        } else if (!Number.isInteger(n) || n &lt;= 0) {
            throw new Error('point_cloud.n must be a positive integer');
        }
        if (typeof c === 'undefined') {
            throw new Error('point_cloud.c must be defined');
        } else if (!Array.isArray(c) || c.length &lt;= 0 || c.some(e =&gt; (typeof e !== 'number'))) {
            throw new Error(`point_cloud.c must be a non-empty array of numbers`);
        }
        if (typeof r === 'undefined') {
            throw new Error('point_cloud.r must be defined');
        } else if (typeof r !== 'number' || r &lt;= 0) {
            throw new Error('point_cloud.r must be a positive number');
        }
        if (typeof dt !== 'undefined' && (typeof dt !== 'number' || dt &lt;= 0)) {
            throw new Error(`point_cloud.dt must be a positive number`);
        }
        if (typeof steps !== 'undefined' && (!Number.isInteger(steps) || steps &lt; 0)) {
            throw new Error('steps point_cloudmust be a non-negative integer');
        }
    }
    function validate_config(config, structure_name='config') {
        if ( typeof config !== 'object') {
            throw new Error(`${structure_name} must be an object`)
        }
        const { integrator, dt, x0, skip, steps, point_cloud } = config;  // params is unrestricted
        if (integrator) {
            validate_integrator(integrator);
        }
        if (typeof dt !== 'undefined' && (typeof dt !== 'number' || dt &lt;= 0)) {
            throw new Error(`${structure_name}.dt must be a positive number`);
        }
        if (typeof x0 !== 'undefined' &&
             (!Array.isArray(x0) || x0.length &lt;= 0 || x0.some(e =&gt; (typeof e !== 'number'))) ) {
            throw new Error(`${structure_name}.x0 must be a non-empty array of numbers`);
        }
        if (typeof skip !== 'undefined' && (!Number.isInteger(skip) || skip &lt; 0)) {
            throw new Error(`${structure_name}.skip must be a non-negative integer`);
        }
        if (typeof steps !== 'undefined' && (!Number.isInteger(steps) || steps &lt; 0)) {
            throw new Error(`${structure_name}.steps must be a non-negative integer`);
        }
        if (point_cloud) {
            validate_point_cloud(point_cloud);
        }
    }
    function validate_equation_def(equation_def) {
        if ( typeof equation_def !== 'object') {
            throw new Error('equation definition must be an object')
        }
        validate_config(equation_def, 'equation_def');  // equation_def is a subclass of config
        const { title, f, iter, iter_delay } = equation_def;
        if (typeof title !== 'undefined' && typeof title !== 'string') {
            throw new Error('equation_def.title must be a string');
        }
        if (iter) {
            const iterator_fn = iter[Symbol.iterator];
            if ( (typeof iterator_fn !== 'undefined' && typeof iterator_fn !== 'function') &&
                 !(iter instanceof Generator) ) {
                throw new Error('equation_def.iter must be an iterable or a generator function');
            }
        }
        if (typeof iter_delay !== 'undefined' && (typeof iter_delay !== 'number' || iter_delay &lt; 0)) {
            throw new Error('equation_def.iter_delay must be a non-negative number');
        }
        if (typeof f === 'undefined') {
            throw new Error('equation_def.f must be defined');
        } else {
            validate_f(f);
        }
    }

    let runner;
    const set_running_state = (running) =&gt; {
        runner?.stop();
        if (running) {
            const new_runner = new Runner(the_equation_def);
            runner = new_runner;
            new_runner.done.then(
                () =&gt; {
                    if (!new_runner.stopped) {
                        set_running_state(false);
                    }
                },
                error =&gt; {
                    if (!new_runner.stopped) {
                        set_running_state(false);
                    }
                }
            );
            point_count_display_el.innerText = '';
            go_button.innerText = 'Stop';
            document.getElementById('ode_plotter_play_controls').scrollIntoView();
        } else {
            runner = undefined;
            go_button.innerText = 'Go';
        }
    }
    go_button.addEventListener('click', async (event) =&gt; {
        set_running_state(!runner);
    });

    class Runner {
        constructor(equation_def) {
            validate_equation_def(equation_def);

            this._equation_def = equation_def;

            this._xs = [];
            this._ys = [];
            this._zs = [];
            this._cs = [];

            this._gdata = [{
                name: 'equation',
                type: 'scatter3d',
                mode: 'lines',
                x: this._xs,
                y: this._ys,
                z: this._zs,
                opacity: 1,
                line: {
                    width: 3,
                    color: this._cs,
                    reversescale: false,
                },
            }];
            this._extrema_trace = {
                name: 'extrema',
                showlegend: false,
                type: 'scatter3d',
                mode: 'markers',
                x: [],
                y: [],
                z: [],
                marker: {
                    color: 'rgba(0, 0, 0, 0.01)',
                    size: 1,
                },
            };
            this._gdata.push(this._extrema_trace);


            display_config();
            set_point_cloud_loop_display(false);

            this._mouse_paused = false;
            this._the_plot_el_mousedown_handler = (event) =&gt; { this._mouse_paused = true; };
            this._the_plot_el_mousedown_handler_options = { capture: true };
            this._the_plot_el_mouseup_handler = (event) =&gt; { this._mouse_paused = false; };
            this._the_plot_el_mouseup_handler_options = { capture: true };
            plot_el.addEventListener(
                'mousedown',
                this._the_plot_el_mousedown_handler,
                this._the_plot_el_mousedown_handler_options
            );
            plot_el.addEventListener(
                'mouseup',
                this._the_plot_el_mouseup_handler,
                this._the_plot_el_mouseup_handler_options
            );

            this._button_paused = false;
            this._the_pause_button_click_handler = (event) =&gt; {
                this._button_paused = !this._button_paused;
                set_pause_button_state(this._button_paused, this._running);
            };
            this._the_pause_button_click_handler_options = {};
            pause_button.addEventListener(
                'click',
                this._the_pause_button_click_handler,
                this._the_pause_button_click_handler_options
            );

            this._stopped = false;
            this._running = false;

            this._done = new Promise(async (resolve, reject) =&gt; {
                this._running = true;
                set_go_button_state(this._running);
                set_pause_button_state(this._button_paused, this._running);

                try {
                    const { title, f, iter_delay } = this._equation_def;

                    let { iter } = this._equation_def;
                    if (!iter) {
                        iter = [{}];  // one empty config
                    } else if (iter instanceof Generator) {
                        iter = iter(this._equation_def);
                    }
                    // iter is now an iterable

                    let first_iteration = true;
                    for (const config of iter) {
                        if (!this._running) {
                            break;
                        }

                        this._clear_data();

                        const merged_config = {
                            ...this._equation_def,  // this._equation_def may contain config properties
                            ...config,              // config properties override those in this._equation_def
                        };
                        validate_config(merged_config);

                        if (iter_delay && !first_iteration) {
                            await new Promise(resolve =&gt; setTimeout(resolve, iter_delay));
                        }
                        first_iteration = false;

                        const { integrator, dt, x0, params, skip=0, steps=Infinity, point_cloud } = merged_config;
                        if (typeof integrator === 'undefined') {
                            throw new Error('integrator was not specified');
                        }
                        if (typeof dt === 'undefined') {
                            throw new Error('dt was not specified');
                        }
                        if (typeof x0 === 'undefined') {
                            throw new Error('x0 was not specified');
                        }

                        display_config(merged_config);

                        let x = [ ...x0 ];  // copy x0 to insulate from mutation
                        if (skip &lt;= 0) {
                            this._add(x);
                        }

                        let plot_fn = Plotly.newPlot;
                        let point_count = 0;
                        while (this._running && point_count &lt; skip+steps) {
                            if (!this.paused) {
                                const points_per_loop = parseInt(points_per_loop_el.value);
                                for (let lp = 0; lp &lt; points_per_loop; lp++) {
                                    if (!this._running) {
                                        break;
                                    }
                                    x = integrator(dt, f, x, params);
                                    point_count++;
                                    if (point_count &gt;= skip) {
                                        this._add(x);
                                    }
                                    if (point_count &gt;= skip+steps) {
                                        break;
                                    }
                                }

                                this._trim_data();

                                if (point_count &gt;= skip) {
                                    this._draw_data(plot_fn);
                                    plot_fn = Plotly.react;
                                }

                                point_count_display_el.innerText = point_count;
                            }

                            if (point_count &lt; skip+steps) {
                                const loop_delay = parseInt(loop_delay_el.value);
                                await new Promise(resolve =&gt; setTimeout(resolve, loop_delay));
                            }
                        }

                        // Done plotting graph for this config.
                        // Finally, run its point cloud, if any.
                        if (this._running && point_cloud) {
                            await this._run_point_cloud(f, merged_config);
                        }
                    }

                    // done
                    resolve();

                } catch (err) {
                    console.error(err.message, err.stack);
                    alert(`${err.message}\n\n${err.stack}`);
                    reject(err);
                }
            });
        }

        get running (){ return this._running; }
        get paused  (){ return this._mouse_paused || this._button_paused; }
        get stopped (){ return this._stopped; }
        get done    (){ return this._done; }

        stop() {
            this._stopped = true;
            this._running = false;
            plot_el.removeEventListener(
                'mousedown',
                this._the_plot_el_mousedown_handler,
                this._the_plot_el_mousedown_handler_options
            );
            plot_el.removeEventListener(
                'mouseup',
                this._the_plot_el_mouseup_handler,
                this._the_plot_el_mouseup_handler_options
            );
            pause_button.removeEventListener(
                'click',
                this._the_pause_button_click_handler,
                this._the_pause_button_click_handler_options
            );
            this._button_paused = false;
            set_pause_button_state(this._button_paused, this._running);
        }

        // internal

        _clear_data() {
            this._xs.splice(0, this._xs.length);
            this._ys.splice(0, this._ys.length);
            this._zs.splice(0, this._zs.length);
            this._cs.splice(0, this._cs.length);
        }

        _trim_data() {
            let limit = parseInt(points_shown_el.value);
            if (isNaN(limit)) {
                limit = 0;
            }
            if (this._xs.length &gt; limit) {
                this._xs.splice(0, this._xs.length-limit);
                this._ys.splice(0, this._ys.length-limit);
                this._zs.splice(0, this._zs.length-limit);
                this._cs.splice(0, this._cs.length-limit);
            }
        }

        _add([x, y, z], c=1) {
            this._xs.push(x ?? 0);
            this._ys.push(y ?? 0);
            this._zs.push(z ?? 0);
            this._cs.push(c);
        }

        _draw_data(plot_fn, no_update_revision=false) {
            // update extrema
            let values_seen = false;
            let min_x = Infinity, max_x = -Infinity,
                min_y = Infinity, max_y = -Infinity,
                min_z = Infinity, max_z = -Infinity;
            for (const trace of this._gdata) {
                if (trace.x.length &gt; 0 || trace.y.length &gt; 0 || trace.z.length &gt; 0) {
                    values_seen = true;
                }

                for (const v of trace.x) {
                    if (v &lt; min_x) {
                        min_x = v;
                    }
                    if (v &gt; max_x) {
                        max_x = v;
                    }
                }
                for (const v of trace.y) {
                    if (v &lt; min_y) {
                        min_y = v;
                    }
                    if (v &gt; max_y) {
                        max_y = v;
                    }
                }
                for (const v of trace.z) {
                    if (v &lt; min_z) {
                        min_z = v;
                    }
                    if (v &gt; max_z) {
                        max_z = v;
                    }
                }
            }
            if (values_seen) {
                this._extrema_trace.x = [ min_x, max_x ];
                this._extrema_trace.y = [ min_y, max_y ];
                this._extrema_trace.z = [ min_z, max_z ];
            }

            // update layout
            const layout = {
                height: plot_height,
            };
            if (!no_update_revision) {
                layout.datarevision = Date.now();
            }
            // note: plot_el._fullLayout is undocumented...
            if (plot_el._fullLayout?.scene?.camera) {
                layout.scene = {
                    camera: plot_el._fullLayout.scene.camera,
                };
            }
            if (this._equation_def?.title) {
                layout.title = this._equation_def.title;
            }
            plot_fn(plot_el, this._gdata, layout);
        }

        async _run_point_cloud(f, config) {
            const { integrator, dt, x0, params, point_cloud } = config;
            const { n, c, r, dt:pc_dt=dt, steps=Infinity } = point_cloud;

            const ArrayType = Float64Array;

            set_point_cloud_loop_display(true, '');

            // config contains point_cloud
            // assume config has already been validated
            if (!this._gdata) {
                throw new Error('unexpected: !this._gdata');
            }

            // set up workers
            const worker_count = worker_pool.workers.length;
            const points_per_worker = Math.floor(n / worker_count);
            const worker_descs = [ ...worker_pool.workers ].map((worker, index) =&gt; {
                const start = index*points_per_worker;
                const end   = (index &gt;= worker_count-1) ? n : (start + points_per_worker);

                const point_count = (end - start);

                const pc_trace = {
                    name: 'point cloud',
                    showlegend: true,
                    type: 'scatter3d',
                    mode: 'markers',
                    marker: {
                        color: 'rgba(0, 0, 255, 1.0)',
                        size: 1,
                    },

                    x: new ArrayType(point_count),
                    y: new ArrayType(point_count),
                    z: new ArrayType(point_count),
                };

                return {
                    worker,
                    index,
                    point_count,
                    pc_trace,
                };
            });
            // initialize worker state, etc
            for (const worker_desc of worker_descs) {
                const worker   = worker_desc.worker;
                const pc_trace = worker_desc.pc_trace;
                // initialize pc_trace x, y, z arrays with the initial values
                for (let i = 0; i &lt; worker_desc.point_count; i++) {
                    // generate the initial positions of the points
                    // the points we generate here lie in a N-cube centered at c
                    // with side length 2*r (where N = c.length).
                    const [ x, y, z ] = c.map(xi =&gt; xi + r*2*(Math.random() - 0.5));
                    pc_trace.x[i] = x;
                    pc_trace.y[i] = y;
                    pc_trace.z[i] = z;
                }

                // add new trace to the graphics data
                this._gdata.push(pc_trace);

                // set up worker state
console.log('worker', worker, 'worker_descs', worker_descs);//!!!
                await worker.eval(`
console.log('this', this);//!!!
                    const { pc_dt, params, point_count, x, y, z } = this;
                    Object.assign(globalThis, { pc_dt, params, point_count, x, y, z });
                    globalThis.integrator = ${integrator.toString()};
                    globalThis.f = ${f.toString()};
                    globalThis.points_buffer = new ArrayBuffer(point_count*3*Float64Array.BYTES_PER_ELEMENT);
                    globalThis.points = [];
                    for (let i = 0; i &lt; point_count; i++) {
                        const point_view = new Float64Array(globalThis.points_buffer, i*3*Float64Array.BYTES_PER_ELEMENT, 3);
                        point_view[0] = x[i];
                        point_view[1] = y[i];
                        point_view[2] = z[i];
                        globalThis.points.push(point_view);
                    }
                `, {
                       pc_dt,
                       params,
                       point_count: worker_desc.point_count,
                       x: pc_trace.x,
                       y: pc_trace.y,
                       z: pc_trace.z,
                   });
            }

            main_loop:
            for (let s = 0; s &lt; steps; /* s incremented below */) {
                while (this.paused && this._running) {
                    await new Promise(resolve =&gt; setTimeout(resolve), 100);
                }
                if (!this._running) {
                    break main_loop;
                }

                // start calculations in workers first, then draw,
                // then wait for calculations to complete

                const iterations = parseInt(point_cloud_points_per_loop_el.value);
                const calc_promise = Promise.all(
                    worker_descs.map(worker_desc =&gt; {
                        return worker_desc.worker
                            .eval(`
                                const { iterations } = this;
                                for (let iteration = 0; iteration &lt; iterations; iteration++) {
                                    for (let i = 0; i &lt; point_count; i++) {
                                        const point = points[i];
                                        const p = integrator(pc_dt, f, point, params);
                                        x[i] = point[0] = p[0];
                                        y[i] = point[1] = p[1];
                                        z[i] = point[2] = p[2];
                                    }
                                }
                                return [ x, y, z ];
                            `, { iterations } )
                            .then(([ new_x, new_y, new_z ]) =&gt; {
                                worker_desc.pc_trace.x = new_x;
                                worker_desc.pc_trace.y = new_y;
                                worker_desc.pc_trace.z = new_z;
                            })
                    })
                );

                this._draw_data(Plotly.react, true);

                await calc_promise;
                s += iterations;

                set_point_cloud_loop_display(true, s+1);

                const loop_delay = parseInt(loop_delay_el.value);
                await new Promise(resolve =&gt; setTimeout(resolve, loop_delay));
            }
        }
    }

    setTimeout(() =&gt; {
        document.getElementById('ode_plotter_adjustments').scrollIntoView(false);
        go_button.focus();
    }, 500);
}

this.setup = setup;</eval-cell>
<output class="eval-cell-output" id="id-748d7ef7-e25e-42ca-b998-be9266ad482f"><div data-type="javascript"></div></output>
<eval-cell data-output-element-id="id-fee90f01-308c-4d4a-a451-35a4ef0dd53c" data-input-type="javascript">
// integrator:
// f(x) returns xdot which has the same dimension as x
// integrator returns a new x with the same dimension as the original

function runge_kutta_integrator(dt, f, x, params) {
    // This is an implementation of the fourth-order Runge-Kutta method
    // as presented in Nonlinear Dynamics and Chaos, Second Edition, by
    // Steven H. Strogatz, page 34.
    // This implementation works for x with arbitrary dimension.
    const k1 = f( x,                                params ).map( xidot =&gt; xidot*dt );
    const k2 = f( x.map( (xi, i) =&gt; xi + k1[i]/2 ), params ).map( xidot =&gt; xidot*dt );
    const k3 = f( x.map( (xi, i) =&gt; xi + k2[i]/2 ), params ).map( xidot =&gt; xidot*dt );
    const k4 = f( x.map( (xi, i) =&gt; xi + k3[i]),    params ).map( xidot =&gt; xidot*dt );
    return x.map( (xi, i) =&gt; xi + (k1[i] + 2*k2[i] + 2*k3[i] + k4[i])/6 );
}

this.runge_kutta_integrator = runge_kutta_integrator;</eval-cell>
<output class="eval-cell-output" id="id-fee90f01-308c-4d4a-a451-35a4ef0dd53c"><div data-type="javascript"></div></output>
<eval-cell data-output-element-id="id-09e6ba70-ca0f-4216-9e21-38874cc36109" data-input-type="javascript">
const go = this.setup.bind(this, ocx);

//////////////////////////////////////////////////////////////////////////////
//
// EquationDef = Config + {
//     title?: string,
//     f: Function,
//     iter?: iterable&lt;Config&gt;|generator&lt;Config&gt;(def: EquationDef),
//     iter_delay?: number,
// }
//
// Config = {
//     integrator?: (dt: number, f: Function, x: number[], params: any) =&gt; number[],
//     dt?: number,
//     x0?: number[],
//     params?: any,
//     skip?:  integer,
//     steps?: integer,
//     point_cloud?: PointCloud,
// }
//
// PointCloud = {
//     n: integer,
//     c: number[];
//     r: number,
//     dt?: number,
//     steps?: integer,
// }
//
// Function = (x: number[], params?: any) =&gt; number[]
//
//////////////////////////////////////////////////////////////////////////////


// Definitions for some chaotic attractors provided by Dr. James P. Crutchfield
// (one of the pioneers of Chaos Theory).
//
// For more information on chaotic attractors see Lecture 3 on the Roadmap page at the course:
//
//                 http://csc.ucdavis.edu/~chaos/courses/poci/

const integrator = this.runge_kutta_integrator;

const lorenz_def = {
    title: 'Lorenz Attractor',
    integrator,
    dt: 0.005,
    x0: [3, 3, 1],
    f:  ( (sigma=10, r=28, b=8/3) =&gt;
          ([x, y, z]) =&gt; [  // this is f, and it takes 1 argument which is decomposed into [x, y, z]
              sigma*(y - x),
              r*x - y - x*z,
              x*y - b*z,
          ]
        )()
};

const owl_def = {
    title: 'Owl Attractor',
    integrator,
    dt: 0.005,
    x0: [3, 3, 1],
    f:  ( (a=10, b=10, c=13) =&gt;
          ([x, y, z]) =&gt; [
              -a*(x + y),
              -y - b*x*z,
              10*x*y + c,
          ]
        )()
};

const rossler_def = {
    title: 'RÃ¶ssler Attractor',
    integrator,
    dt: 0.008,
    x0: [10, 10, 1],
    f:  ( (a=0.2, b=0.2, c=5.7) =&gt;
         ([x, y, z]) =&gt; [
             -y - z,
             x + a*y,
             b + z*(x - c),
         ]
        )()
};

const rikitake0_def = {  // see: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7517210/
    title: 'Rikitake Attractor ( from https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7517210/ )',
    integrator,
    dt: 0.01,
    x0: [3, 1, 6],
    f:  ( (alpha=5, beta=2) =&gt;
          ([x, y, z]) =&gt; [
              -beta*x + y*z,
              -beta*y - alpha*x + x*z,
              1 - x*y,
          ]
        )()
};

const rikitake_def = {
    title: 'Rikitake Attractor',
    integrator,
    dt: 0.009,
    x0: [0.268, 2, 0],
    f:  ( (a=1, b=3.75) =&gt;
          ([x, y, z]) =&gt; [
              -a*x + z*y,
              -a*y - (z - b)*x,
              1 - x*y,
          ]
        )()
};

const hyperchaos_def = {
    title: 'Hyperchaos Attractor',
    integrator,
    dt: 0.005,
    x0: [-20, 15, 0, 35],
    f:  ( (a=0.25, b=-0.5, c=2.2, d=0.05) =&gt;
          ([x, y, z, w]) =&gt; [
              -y - z,
              x + a*y + w,
              c + x*z,
              b*z + d*w,
          ]
        )()
};

const point_cloud_def = {
    title: 'Lorenz Attractor With Point Cloud',
    integrator,
    dt: 0.005,
    x0: [3, 3, 1],
    params: { sigma: 10, r: 28, b: 8/3 },
    f:  ([x, y, z], {sigma, r, b}) =&gt; [
             sigma*(y - x),
             r*x - y - x*z,
             x*y - b*z,
        ],
    skip:  1000,
    steps: 10000,
    point_cloud: {
        n: 10000,
        c: [1, 1, 1],
        r: 0.05,
        dt: 0.05,
    }
};

// set the equation definition to plot

// go(lorenz_def);
// go(owl_def);
// go(rossler_def);
// go(rikitake0_def);
// go(rikitake_def);
// go(hyperchaos_def);

go(point_cloud_def);
</eval-cell>
<output class="eval-cell-output" id="id-09e6ba70-ca0f-4216-9e21-38874cc36109"><div data-type="javascript"><div>
<style>
    #ode_plotter_info_display {
        display: flex;
        gap: 2rem;
    }

    #ode_plotter_play_controls {
        padding-top: 0.5rem;
        padding-bottom: 0.5rem;
    }

    #ode_plotter_controls {
        width: fit-content;
    }
    #ode_plotter_controls div * {
        vertical-align: middle;
    }

    #ode_plotter_adjustments {
        display: grid;
        grid-template-columns: max-content max-content;
        gap: 0.5rem;
    }
    #ode_plotter_adjustments label {
        justify-self: end;
    }

    #ode_plotter_config_display {
        width: fit-content;
        font-family: monospace;
    }

    .ode_plotter_display {
        margin-left: 0.1rem;
        padding: 0 0.5rem;
        background-color: #eee;
    }

    .hidden {
        display: none;
    }
</style>

<div id="ode_plotter_play_controls">
    <button id="ode_plotter_go">Go</button>
    <button id="ode_plotter_pause" class="hidden">Pause</button>
</div>
<div id="ode_plotter_info_display">
    <div id="ode_plotter_controls">
        <div id="ode_plotter_adjustments">
            <label for="points_per_loop">Time steps per loop</label>
            <div>
                <input id="points_per_loop" type="range" min="1" max="10000" value="1000">
                <span id="points_per_loop_display" class="ode_plotter_display">1000</span>
            </div>
            <label for="loop_delay">Loop delay</label>
            <div>
                <input id="loop_delay" type="range" min="0" max="500" value="0">
                <span id="loop_delay_display" class="ode_plotter_display">0</span> ms
            </div>
            <label for="points_shown">Time steps shown</label>
            <div>
                <input id="points_shown" type="range" min="0" max="100000" step="10" value="20000">
                <span id="points_shown_display" class="ode_plotter_display">20000</span>
            </div>
            <label for="point_count_display">Total time steps</label>
            <div>
                <span id="point_count_display" class="ode_plotter_display">11000</span>
            </div>
            <label class="" for="point_cloud_loop_display">Point cloud steps</label>
            <div class="">
                <span id="point_cloud_loop_display" class="ode_plotter_display"></span>
            </div>
            <label class="" for="point_cloud_points_per_loop">PC steps per loop</label>
            <div class="">
                <input id="point_cloud_points_per_loop" type="range" min="1" max="100" value="1">
                <span id="point_cloud_points_per_loop_display" class="ode_plotter_display">1</span>
            </div>
        </div>
    </div>
    <div id="ode_plotter_config_display" class="">--- CONFIG ---<br>dt: 0.005<br>x0: [3, 3, 1]<br>params: {"sigma":10,"r":28,"b":2.6666666666666665}<br>skip: 1000<br>steps: 10000<br>--- point cloud ---<br>n: 10000, c: [1, 1, 1], dt: 0.05}</div>
</div>
<div id="ode_plotter_plot" style="height: 720px;" class="js-plotly-plot"><div class="plot-container plotly"><div class="user-select-none svg-container" style="position: relative; width: 754.422px; height: 720px;"><svg class="main-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="754.422" height="720" style="background: rgb(255, 255, 255);"><defs id="defs-f510fe"><g class="clips"></g><g class="gradients"></g><g class="patterns"></g></defs><g class="bglayer"></g><g class="draglayer"></g><g class="layer-below"><g class="imagelayer"></g><g class="shapelayer"></g></g><g class="cartesianlayer"></g><g class="polarlayer"></g><g class="smithlayer"></g><g class="ternarylayer"></g><g class="geolayer"></g><g class="funnelarealayer"></g><g class="pielayer"></g><g class="iciclelayer"></g><g class="treemaplayer"></g><g class="sunburstlayer"></g><g class="glimages"></g></svg><div class="gl-container"><div id="scene" style="position: absolute; left: 80px; top: 100px; height: 540px; width: 559px;"><svg viewBox="0 0 559 540" width="559" height="540" style="position: absolute; left: 0px; top: 0px; height: 100%; width: 100%; z-index: 20; pointer-events: none;"></svg><canvas width="1118" height="1080" style="position: absolute; left: 0px; top: 0px; width: 559px; height: 540px;"></canvas></div></div><svg class="main-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="754.422" height="720"><defs id="topdefs-f510fe"><g class="clips"></g><clipPath id="legendf510fe"><rect width="92" height="29" x="0" y="0"></rect></clipPath></defs><g class="indicatorlayer"></g><g class="layer-above"><g class="imagelayer"></g><g class="shapelayer"></g></g><g class="selectionlayer"></g><g class="infolayer"><g class="legend" pointer-events="all" transform="translate(650.1800000000001,100)"><rect class="bg" shape-rendering="crispEdges" width="92" height="29" x="0" y="0" style="stroke: rgb(68, 68, 68); stroke-opacity: 1; fill: rgb(255, 255, 255); fill-opacity: 1; stroke-width: 0px;"></rect><g class="scrollbox" transform="" clip-path="url(#legendf510fe)"><g class="groups"><g class="traces" transform="translate(0,14.5)" style="opacity: 1;"><text class="legendtext" text-anchor="start" x="40" y="4.680000000000001" data-unformatted="equation" data-math="N" style="font-family: &quot;Open Sans&quot;, verdana, arial, sans-serif; font-size: 12px; fill: rgb(68, 68, 68); fill-opacity: 1; white-space: pre;">equation</text><g class="layers" style="opacity: 1;"><g class="legendfill"></g><g class="legendlines"><path class="js-line" d="M5,0h30" style="fill: none; stroke: rgb(0, 0, 0); stroke-opacity: 1; stroke-width: 3px;"></path></g><g class="legendsymbols"><g class="legendpoints"></g></g></g><rect class="legendtoggle" pointer-events="all" x="0" y="-9.5" width="86.046875" height="19" style="cursor: pointer; fill: rgb(0, 0, 0); fill-opacity: 0;"></rect></g></g></g><rect class="scrollbar" rx="20" ry="3" width="0" height="0" x="0" y="0" style="fill: rgb(128, 139, 164); fill-opacity: 1;"></rect></g><g class="g-gtitle"><text class="gtitle" x="377.211" y="50" text-anchor="middle" dy="0em" data-unformatted="Lorenz Attractor With Point Cloud" data-math="N" style="font-family: &quot;Open Sans&quot;, verdana, arial, sans-serif; font-size: 17px; fill: rgb(68, 68, 68); opacity: 1; font-weight: normal; white-space: pre;">Lorenz Attractor With Point Cloud</text></g></g><g class="menulayer"></g><g class="zoomlayer"></g></svg><div class="modebar-container" style="position: absolute; top: 0px; right: 0px; width: 100%;"><div id="modebar-f510fe" class="modebar modebar--hover ease-bg"><div class="modebar-group"><a rel="tooltip" class="modebar-btn" data-title="Download plot as a png" data-toggle="false" data-gravity="n"><svg viewBox="0 0 1000 1000" class="icon" height="1em" width="1em"><path d="m500 450c-83 0-150-67-150-150 0-83 67-150 150-150 83 0 150 67 150 150 0 83-67 150-150 150z m400 150h-120c-16 0-34 13-39 29l-31 93c-6 15-23 28-40 28h-340c-16 0-34-13-39-28l-31-94c-6-15-23-28-40-28h-120c-55 0-100-45-100-100v-450c0-55 45-100 100-100h800c55 0 100 45 100 100v450c0 55-45 100-100 100z m-400-550c-138 0-250 112-250 250 0 138 112 250 250 250 138 0 250-112 250-250 0-138-112-250-250-250z m365 380c-19 0-35 16-35 35 0 19 16 35 35 35 19 0 35-16 35-35 0-19-16-35-35-35z" transform="matrix(1 0 0 -1 0 850)"></path></svg></a></div><div class="modebar-group"><a rel="tooltip" class="modebar-btn" data-title="Zoom" data-attr="scene.dragmode" data-val="zoom" data-toggle="false" data-gravity="n"><svg viewBox="0 0 1000 1000" class="icon" height="1em" width="1em"><path d="m1000-25l-250 251c40 63 63 138 63 218 0 224-182 406-407 406-224 0-406-182-406-406s183-406 407-406c80 0 155 22 218 62l250-250 125 125z m-812 250l0 438 437 0 0-438-437 0z m62 375l313 0 0-312-313 0 0 312z" transform="matrix(1 0 0 -1 0 850)"></path></svg></a><a rel="tooltip" class="modebar-btn" data-title="Pan" data-attr="scene.dragmode" data-val="pan" data-toggle="false" data-gravity="n"><svg viewBox="0 0 1000 1000" class="icon" height="1em" width="1em"><path d="m1000 350l-187 188 0-125-250 0 0 250 125 0-188 187-187-187 125 0 0-250-250 0 0 125-188-188 186-187 0 125 252 0 0-250-125 0 187-188 188 188-125 0 0 250 250 0 0-126 187 188z" transform="matrix(1 0 0 -1 0 850)"></path></svg></a><a rel="tooltip" class="modebar-btn" data-title="Orbital rotation" data-attr="scene.dragmode" data-val="orbit" data-toggle="false" data-gravity="n"><svg viewBox="0 0 1000 1000" class="icon" height="1em" width="1em"><path d="m922 660c-5 4-9 7-14 11-359 263-580-31-580-31l-102 28 58-400c0 1 1 1 2 2 118 108 351 249 351 249s-62 27-100 42c88 83 222 183 347 122 16-8 30-17 44-27-2 1-4 2-6 4z m36-329c0 0 64 229-88 296-62 27-124 14-175-11 157-78 225-208 249-266 8-19 11-31 11-31 2 5 6 15 11 32-5-13-8-20-8-20z m-775-239c70-31 117-50 198-32-121 80-199 346-199 346l-96-15-58-12c0 0 55-226 155-287z m603 133l-317-139c0 0 4-4 19-14 7-5 24-15 24-15s-177-147-389 4c235-287 536-112 536-112l31-22 100 299-4-1z m-298-153c6-4 14-9 24-15 0 0-17 10-24 15z" transform="matrix(1 0 0 -1 0 850)"></path></svg></a><a rel="tooltip" class="modebar-btn active" data-title="Turntable rotation" data-attr="scene.dragmode" data-val="turntable" data-toggle="false" data-gravity="n"><svg viewBox="0 0 1000 1000" class="icon" height="1em" width="1em"><path d="m833 5l-17 108v41l-130-65 130-66c0 0 0 38 0 39 0-1 36-14 39-25 4-15-6-22-16-30-15-12-39-16-56-20-90-22-187-23-279-23-261 0-341 34-353 59 3 60 228 110 228 110-140-8-351-35-351-116 0-120 293-142 474-142 155 0 477 22 477 142 0 50-74 79-163 96z m-374 94c-58-5-99-21-99-40 0-24 65-43 144-43 79 0 143 19 143 43 0 19-42 34-98 40v216h87l-132 135-133-135h88v-216z m167 515h-136v1c16 16 31 34 46 52l84 109v54h-230v-71h124v-1c-16-17-28-32-44-51l-89-114v-51h245v72z" transform="matrix(1 0 0 -1 0 850)"></path></svg></a></div><div class="modebar-group"><a rel="tooltip" class="modebar-btn" data-title="Reset camera to default" data-attr="resetDefault" data-toggle="false" data-gravity="n"><svg viewBox="0 0 928.6 1000" class="icon" height="1em" width="1em"><path d="m786 296v-267q0-15-11-26t-25-10h-214v214h-143v-214h-214q-15 0-25 10t-11 26v267q0 1 0 2t0 2l321 264 321-264q1-1 1-4z m124 39l-34-41q-5-5-12-6h-2q-7 0-12 3l-386 322-386-322q-7-4-13-4-7 2-12 7l-35 41q-4 5-3 13t6 12l401 334q18 15 42 15t43-15l136-114v109q0 8 5 13t13 5h107q8 0 13-5t5-13v-227l122-102q5-5 6-12t-4-13z" transform="matrix(1 0 0 -1 0 850)"></path></svg></a><a rel="tooltip" class="modebar-btn" data-title="Reset camera to last save" data-attr="resetLastSave" data-toggle="false" data-gravity="n"><svg viewBox="0 0 1000 1000" class="icon" height="1em" width="1em"><path d="m938 413l-188-125c0 37-17 71-44 94 64 38 107 107 107 187 0 121-98 219-219 219-121 0-219-98-219-219 0-61 25-117 66-156h-115c30 33 49 76 49 125 0 103-84 187-187 187s-188-84-188-187c0-57 26-107 65-141-38-22-65-62-65-109v-250c0-70 56-126 125-126h500c69 0 125 56 125 126l188-126c34 0 62 28 62 63v375c0 35-28 63-62 63z m-750 0c-69 0-125 56-125 125s56 125 125 125 125-56 125-125-56-125-125-125z m406-1c-87 0-157 70-157 157 0 86 70 156 157 156s156-70 156-156-70-157-156-157z" transform="matrix(1 0 0 -1 0 850)"></path></svg></a></div><div class="modebar-group"><a href="https://plotly.com/" target="_blank" data-title="Produced with Plotly.js (v2.16.0)" class="modebar-btn plotlyjsicon modebar-btn--logo"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 132 132" height="1em" width="1em"><defs> <style>  .cls-0{fill:#000;}  .cls-1{fill:#FFF;}  .cls-2{fill:#F26;}  .cls-3{fill:#D69;}  .cls-4{fill:#BAC;}  .cls-5{fill:#9EF;} </style></defs> <title>plotly-logomark</title> <g id="symbol">  <rect class="cls-0" x="0" y="0" width="132" height="132" rx="18" ry="18"></rect>  <circle class="cls-5" cx="102" cy="30" r="6"></circle>  <circle class="cls-4" cx="78" cy="30" r="6"></circle>  <circle class="cls-4" cx="78" cy="54" r="6"></circle>  <circle class="cls-3" cx="54" cy="30" r="6"></circle>  <circle class="cls-2" cx="30" cy="30" r="6"></circle>  <circle class="cls-2" cx="30" cy="54" r="6"></circle>  <path class="cls-1" d="M30,72a6,6,0,0,0-6,6v24a6,6,0,0,0,12,0V78A6,6,0,0,0,30,72Z"></path>  <path class="cls-1" d="M78,72a6,6,0,0,0-6,6v24a6,6,0,0,0,12,0V78A6,6,0,0,0,78,72Z"></path>  <path class="cls-1" d="M54,48a6,6,0,0,0-6,6v48a6,6,0,0,0,12,0V54A6,6,0,0,0,54,48Z"></path>  <path class="cls-1" d="M102,48a6,6,0,0,0-6,6v48a6,6,0,0,0,12,0V54A6,6,0,0,0,102,48Z"></path> </g></svg></a></div></div></div><svg class="main-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="754.422" height="720"><g class="hoverlayer"></g></svg></div></div></div>
</div></div></output>
</body>
</html>
